SET search_path TO public;
-- query type 1
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(6 rows)

-- query type 2
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Nested Loop
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (val < 10)
               ->  Bitmap Index Scan on t1_val
                     Index Cond: (val < 10)
         ->  Materialize
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(9 rows)

-- query type 3
EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t4.ctid" without the necessary companion column "t4.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Merge Join
         Merge Cond: (t3.id = t4.id)
         ->  Index Scan using t3_pkey on t3
         ->  Sort
               Sort Key: t4.id
               ->  Seq Scan on t4
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

-- query type 4
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Nested Loop
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(7 rows)

-- query type 5
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(7 rows)

-- query type 6
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Nested Loop
         ->  Merge Join
               Merge Cond: (t1.id = t4.id)
               ->  Merge Join
                     Merge Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                     ->  Index Scan using t2_pkey on t2
               ->  Sort
                     Sort Key: t4.id
                     ->  Seq Scan on t4
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(14 rows)

